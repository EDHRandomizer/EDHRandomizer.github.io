<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commander Randomizer - Game Mode</title>
    
    <meta property="og:title" content="Commander Randomizer - Game Mode">
    <meta property="og:description" content="Multiplayer commander randomizer with perks! üé≤">
    <meta property="og:type" content="website">
    
    <link rel="icon" type="image/png" href="images/randomizer-icon.png">
    <link rel="stylesheet" href="css/style.css?v=3.8">
    <link rel="stylesheet" href="css/perk-reveal.css">
    
    <style>
        /* Game Mode Specific Styles */
        .game-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            text-align: center;
            color: white;
        }

        .game-header h1 {
            margin: 0 0 0.5rem 0;
            font-size: 2rem;
        }

        .session-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .session-code {
            font-size: 1.5rem;
            font-weight: bold;
            letter-spacing: 0.1em;
            background: rgba(255,255,255,0.2);
            padding: 0.5rem 1rem;
            border-radius: 6px;
        }

        .lobby-section {
            background: var(--card-bg, #1a1a1a);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        /* Center join/create and name entry sections */
        .lobby-section.centered {
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 2rem;
        }

        /* Also center lobby section */
        #lobby-section {
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .lobby-players {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .lobby-player {
            background: var(--input-bg, #2a2a2a);
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .lobby-player.active {
            border: 2px solid var(--accent-color, #58a6ff);
        }

        .kick-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            white-space: nowrap;
            transition: background 0.2s;
        }

        .kick-btn:hover {
            background: #cc0000;
        }

        .kick-btn:active {
            transform: scale(0.95);
        }

        .lobby-player.disconnected {
            opacity: 0.5;
            border-color: #ff6b6b;
            background: repeating-linear-gradient(
                45deg,
                var(--input-bg, #2a2a2a),
                var(--input-bg, #2a2a2a) 10px,
                #3a2a2a 10px,
                #3a2a2a 20px
            );
        }

        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 900px) {
            .player-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .commander-img-large {
                width: 150px;
            }
            
            .commander-item-large {
                padding: 1rem;
            }
            
            .locked-commander-display h3 {
                font-size: 1.1rem;
            }

            /* Stack join/create columns on mobile */
            #join-create-section > div {
                grid-template-columns: 1fr !important;
            }
        }

        .player-section {
            background: var(--card-bg, #1a1a1a);
            border: 2px solid var(--border-color, #333);
            border-radius: 8px;
            padding: 1rem;
            position: relative;
            transition: all 0.3s ease;
        }

        .player-section.current-player {
            border-color: var(--accent-color, #58a6ff);
            border-width: 3px;
            background: linear-gradient(135deg, #1a2a3a 0%, #1a1a1a 100%);
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.5), 0 0 40px rgba(88, 166, 255, 0.2);
        }

        .player-section.current-player::before {
            content: 'üë§ YOUR SELECTION';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            padding: 4px 16px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .player-section.locked {
            border-color: #4caf50;
        }

        .player-section.disconnected {
            opacity: 0.6;
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #2a1a1a 0%, #1a1a1a 100%);
        }

        .player-section.disconnected::after {
            content: '‚ö†Ô∏è DISCONNECTED';
            position: absolute;
            top: -12px;
            right: 16px;
            background: #ff6b6b;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
            padding-bottom: 0.4rem;
            border-bottom: 1px solid var(--border-color, #333);
        }

        .player-number {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .player-status {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .perk-display {
            background: #616161;
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.3rem;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 0.5rem;
            min-height: 28px;
            cursor: help;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .perk-display:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .perk-display.common {
            background: #616161;
        }

        .perk-display.uncommon {
            background: #2e7d32;
        }

        .perk-display.rare {
            background: #7b1fa2;
            transition: all 0.3s ease;
        }

        .perk-display.rare:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            transform: scale(1.02);
        }

        .perk-display.mythic {
            background: #ef6c00;
            transition: all 0.3s ease;
        }

        .perk-display.mythic:hover {
            box-shadow: 0 0 25px rgba(239, 108, 0, 0.8);
            transform: scale(1.02);
            animation: glow-mythic 2s ease-in-out infinite;
        }

        .perk-name {
            font-weight: 500;
            font-size: 0.95rem;
            flex: 1;
            text-align: left;
        }

        .perk-rarity {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            opacity: 0.9;
            padding-left: 1rem;
        }

        .perks-rolling-placeholder {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 1.5rem;
            margin-bottom: 0.3rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            text-align: center;
            /* Height is set dynamically via inline style to match number of perks */
        }

        .perks-rolling-placeholder .player-name-label {
            font-weight: 600;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.9);
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .perks-container {
            margin-bottom: 1rem;
        }

        .player-settings {
            background: var(--input-bg, #2a2a2a);
            padding: 0.6rem 0.8rem;
            border-radius: 6px;
            margin-bottom: 0.6rem;
        }

        .player-settings:empty {
            display: none;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-label {
            font-weight: bold;
            min-width: 80px;
        }

        .quantity-display {
            font-size: 1.1rem;
        }

        .quantity-modifier {
            color: var(--accent-color, #58a6ff);
            font-size: 0.9rem;
        }

        .color-filter-checkboxes {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .color-filter-checkboxes .color-checkbox {
            width: 45px;
            height: 45px;
        }

        .color-filter-instruction {
            display: block;
        }

        .color-filter-warning {
            display: block;
            margin-top: 0.25rem;
        }

        .color-filter-inline {
            display: flex;
            gap: 0.4rem;
        }

        .color-symbol {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .color-symbol.W { background: #f9faf4; color: #000; }
        .color-symbol.U { background: #0e68ab; color: #fff; }
        .color-symbol.B { background: #150b00; color: #fff; }
        .color-symbol.R { background: #d3202a; color: #fff; }
        .color-symbol.G { background: #00733e; color: #fff; }

        .color-symbol.selected {
            border-color: var(--accent-color, #58a6ff);
            box-shadow: 0 0 8px rgba(88, 166, 255, 0.5);
        }

        .color-symbol.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .commander-grid-small {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.8rem;
            margin: 0.8rem 0;
        }

        .commander-item-small {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0;
            animation: fadeIn 0.5s ease-out forwards;
            opacity: 0;
        }

        /* Stagger animation for each commander */
        .commander-item-small:nth-child(1) { animation-delay: 0.05s; }
        .commander-item-small:nth-child(2) { animation-delay: 0.1s; }
        .commander-item-small:nth-child(3) { animation-delay: 0.15s; }
        .commander-item-small:nth-child(4) { animation-delay: 0.2s; }
        .commander-item-small:nth-child(5) { animation-delay: 0.25s; }
        .commander-item-small:nth-child(6) { animation-delay: 0.3s; }
        .commander-item-small:nth-child(7) { animation-delay: 0.35s; }
        .commander-item-small:nth-child(8) { animation-delay: 0.4s; }
        .commander-item-small:nth-child(9) { animation-delay: 0.45s; }
        .commander-item-small:nth-child(10) { animation-delay: 0.5s; }

        .commander-checkbox-container {
            width: 100%;
            margin-top: -4px;
        }

        .commander-checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 0 0 6px 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
            line-height: 1.2;
            min-height: 36px;
        }

        .commander-checkbox-label:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-color, #58a6ff);
        }

        .commander-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            flex-shrink: 0;
            align-self: flex-start;
            margin-top: 2px;
        }

        .commander-name-label {
            flex: 1;
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .commander-img-small {
            width: 100%;
            height: auto;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .commander-img-small:hover {
            transform: scale(1.02);
        }

        .commander-item-small.selected .commander-checkbox-label {
            background: rgba(88, 166, 255, 0.2);
            border-color: var(--accent-color, #58a6ff);
            box-shadow: 0 0 10px rgba(88, 166, 255, 0.3);
        }

        .commander-item-small.selected .commander-img-small {
            border: 3px solid var(--accent-color, #58a6ff);
            border-bottom: none;
            box-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
        }

        /* Locked commander styling - enhanced selected state */
        .commander-item-small.locked {
            position: relative;
        }

        .commander-item-small.locked::before {
            content: 'üîí';
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 24px;
            z-index: 10;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 215, 0, 0.6);
            filter: drop-shadow(0 0 2px gold);
        }

        .commander-item-small.locked .commander-img-small {
            border: 3px solid gold;
            border-bottom: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .commander-item-small.locked .commander-checkbox-label {
            background: rgba(255, 215, 0, 0.15);
            border-color: gold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }

        /* Locked Commander Display Styles */
        .locked-commander-display {
            grid-column: 1 / -1; /* Span all grid columns */
            text-align: center;
            padding: 1rem;
            width: 100%;
        }

        .locked-commander-display h3 {
            margin: 0 0 1rem 0;
            color: var(--accent-color, #58a6ff);
        }

        .commander-item-large {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--accent-color, #58a6ff);
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 0 15px rgba(88, 166, 255, 0.3);
            max-width: 400px;
            margin: 0 auto;
        }

        .commander-img-large {
            max-width: 300px;
            width: 100%;
            height: auto;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .commander-img-large:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(74, 144, 226, 0.5);
        }

        .commander-details {
            text-align: center;
        }

        .commander-details h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1.2rem;
            color: var(--fg-color, #ffffff);
        }

        .commander-details p {
            margin: 0 0 1rem 0;
            opacity: 0.8;
        }

        .edhrec-link {
            color: var(--accent-color, #58a6ff);
            text-decoration: none;
            padding: 0.5rem 1rem;
            background: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--accent-color, #58a6ff);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .edhrec-link:hover {
            background: rgba(88, 166, 255, 0.2);
            transform: translateY(-1px);
        }

        /* Other Player Label Styles */
        .commander-checkbox-label.other-player {
            cursor: default;
            padding-left: 12px; /* Compensate for missing checkbox space */
        }

        .commander-checkbox-label.other-player:hover {
            background: rgba(255, 255, 255, 0.05); /* Less prominent hover */
        }

        .pack-codes-section {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            padding: 2rem;
            border-radius: 8px;
            color: white;
        }

        .pack-codes-section h2 {
            margin-top: 0;
            text-align: center;
        }

        .pack-code-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .pack-code-item {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 1.5rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.2s;
            min-width: 0; /* Allow grid items to shrink below min-content */
            overflow: hidden; /* Prevent content overflow */
        }

        .pack-code-item:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .pack-player-header {
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 0.75rem;
        }

        .pack-player-name {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 0;
        }

        .pack-player-perks {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.5rem;
        }

        .perk-badge {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 1px solid;
        }

        .perk-badge.common {
            background: #616161;
            border-color: #757575;
            color: #e0e0e0;
        }

        .perk-badge.uncommon {
            background: #2e7d32;
            border-color: #388e3c;
            color: #a5d6a7;
        }

        .perk-badge.rare {
            background: #7b1fa2;
            border-color: #8e24aa;
            color: #ce93d8;
        }

        .perk-badge.mythic {
            background: #ef6c00;
            border-color: #f57c00;
            color: #ffcc80;
        }

        .pack-commander-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: #2a2d35;
            border-radius: 8px;
        }
        
        .pack-commander-img-container {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .pack-commander-img {
            width: 100%;
            max-width: 240px;
            height: auto;
            border-radius: 12px;
            cursor: pointer;
            transition: box-shadow 0.2s;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .pack-commander-img:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }
        
        .pack-commander-info {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .pack-commander-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            color: #ffffff;
            text-align: center;
        }
        
        .pack-perks-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .pack-perk-item {
            display: flex;
            align-items: center;
            padding: 0.6rem 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            border-left: 4px solid;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .pack-perk-item.common {
            background: rgba(97, 97, 97, 0.4);
            border-color: #9e9e9e;
            color: #f5f5f5;
        }

        .pack-perk-item.uncommon {
            background: rgba(76, 175, 80, 0.25);
            border-color: #66bb6a;
            color: #c8e6c9;
        }

        .pack-perk-item.rare {
            background: rgba(156, 39, 176, 0.25);
            border-color: #ab47bc;
            color: #e1bee7;
        }

        .pack-perk-item.mythic {
            background: rgba(255, 152, 0, 0.25);
            border-color: #ffa726;
            color: #ffe082;
        }

        .pack-code-display {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }

        .pack-code {
            font-size: 1.5rem;
            font-weight: bold;
            letter-spacing: 0.15em;
            font-family: 'Courier New', monospace;
            margin: 0.5rem 0;
        }

        .pack-code-label {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-bottom: 0.25rem;
        }

        .hidden {
            display: none !important;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Game Header -->
        <header class="game-header">
            <h1>üé≤ Commander Randomizer - Game Mode</h1>
            <div class="session-info hidden" id="session-info">
                <span>Session Code:</span>
                <span class="session-code" id="session-code-display">-----</span>
                <button class="btn btn-small" id="copy-session-code">Copy</button>
                <button class="btn btn-small" id="leave-session">Leave Session</button>
                <button class="btn btn-small hidden" id="force-advance-btn" style="background: #ff9800; border-color: #ff9800;">‚è≠Ô∏è Force Advance</button>
            </div>
        </header>

        <!-- Join/Create Section -->
        <section id="join-create-section" class="lobby-section centered">
            <h2 style="text-align: center;">Get Started</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1rem;">
                <div>
                    <h3>Host New Game</h3>
                    <p style="opacity: 0.8; font-size: 0.9rem;">Create a new session and invite friends</p>
                    
                    <!-- Host Settings -->
                    <div style="background: rgba(255,255,255,0.05); padding: 1rem; border-radius: 6px; margin: 1rem 0;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">Perks Per Player:</label>
                        <input type="number" id="create-perks-count" class="form-control" value="6" min="1" max="10" style="width: 100px;">
                        <p style="opacity: 0.7; font-size: 0.85rem; margin: 0.5rem 0 0 0;">Players will each get this many random perks</p>
                        
                        <!-- Avatar Mode Checkbox -->
                        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                            <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500;">
                                <input type="checkbox" id="create-avatar-mode" style="margin-right: 0.5rem; width: 18px; height: 18px; cursor: pointer;">
                                <span>Avatar: The Last Airbender Mode</span>
                            </label>
                            <p style="opacity: 0.7; font-size: 0.85rem; margin: 0.5rem 0 0 0;">
                                Weekly commanders from TLA and TLE sets only
                            </p>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" id="create-session-btn">Create Session</button>
                </div>
                <div>
                    <h3>Join Existing Game</h3>
                    <p style="opacity: 0.8; font-size: 0.9rem;">Enter a session code to join</p>
                    <input type="text" id="join-code-input" class="form-control" placeholder="Enter session code" maxlength="5" style="margin-bottom: 0.5rem; text-transform: uppercase;">
                    <button class="btn btn-primary" id="join-session-btn">Join Session</button>
                </div>
            </div>
        </section>

        <!-- Enter Name Section (after joining/creating) -->
        <section id="enter-name-section" class="lobby-section centered hidden">
            <h2 style="text-align: center;">Choose Your Name</h2>
            <p style="text-align: center; opacity: 0.8;">Enter a display name or skip to use a default name</p>
            <div style="max-width: 500px; margin: 1.5rem auto;">
                <input type="text" id="player-name-input" class="form-control" placeholder="Enter your name (optional)" maxlength="20" style="margin-bottom: 1rem; font-size: 1.1rem;">
                
                <button class="btn btn-primary" id="confirm-name-btn" style="width: 100%;">Continue</button>
            </div>
            <p style="text-align: center; opacity: 0.6; font-size: 0.85rem; margin-top: 1rem;">
                Session Code: <strong id="temp-session-code">-----</strong>
            </p>
        </section>

        <!-- Lobby (before perks rolled) -->
        <section id="lobby-section" class="lobby-section hidden">
            <h2>Lobby</h2>
            <div class="lobby-players" id="lobby-players">
                <!-- Player slots populated by JS -->
            </div>
            <button class="btn btn-primary" id="roll-perks-btn">Start Game</button>
            <p style="margin-top: 1rem; opacity: 0.8;">Waiting for host to start the game...</p>
        </section>

        <!-- Perk Reveal Page -->
        <div id="perk-reveal-page">
            <div class="perk-reveal-header">
                <h1 class="perk-reveal-title">‚ú® Your Perks ‚ú®</h1>
                <p class="perk-reveal-subtitle">Click cards to reveal your perks!</p>
                <button id="perk-reveal-continue-top" class="perk-reveal-btn perk-reveal-btn-top" disabled>Continue</button>
            </div>
            
            <div id="perk-cards-container"></div>
            
            <div class="perk-reveal-controls">
                <button id="perk-reveal-continue" class="perk-reveal-btn" disabled>Continue</button>
            </div>
        </div>

        <!-- Player Grid (after perks rolled) -->
        <section id="player-grid-section" class="hidden">
            <div class="player-grid" id="player-grid">
                <!-- Player sections populated by JS -->
            </div>
        </section>

        <!-- Pack Codes (when all locked in) -->
        <section id="pack-codes-section" class="pack-codes-section hidden">
            <h2>üéâ All Players Locked In!</h2>
            <p style="text-align: center; margin: 0;">Your pack codes are ready! Click "Copy TTS Command" to copy to clipboard.</p>
            <div class="pack-code-list" id="pack-code-list">
                <!-- Pack codes populated by JS -->
            </div>
        </section>

        <!-- TTS Instructions (persistent, shown only when pack codes visible) -->
        <div id="tts-instructions" class="hidden" style="text-align: center; margin: 1rem 0; font-size: 0.9rem; color: #888;">
            <strong>üìù TTS Instructions:</strong> In Tabletop Simulator chat, type: <code style="background: #2a2a2a; padding: 2px 6px; border-radius: 3px;">edhrandomizer [YOUR_CODE]</code>
        </div>

        <!-- Status Message -->
        <div id="status-message" style="text-align: center; margin: 1rem 0; min-height: 24px;">
            <!-- Status messages appear here -->
        </div>
    </div>

    <!-- Scripts -->
    <script type="module">
        import { SessionManager } from './js/game-session/sessionManager.js';
        import { PerkLoader } from './js/game-session/perkLoader.js';
        import { PackConfigGenerator } from './js/game-session/packConfigGenerator.js';
        import { GameModeController } from './js/game-session/gameModeController.js';
        import { PerkRevealController } from './js/game-session/perkRevealController.js';
        import { getCsvInfo } from './js/dataLoader.js';

        // Initialize
        let sessionManager;
        let perkLoader;
        let packConfigGenerator;
        let gameModeController;
        let perkRevealController;
        let currentSession = null;
        let currentPlayerId = null;
        let perksData = null;
        let playerCommandersGenerated = {}; // Track which players have generated commanders
        let packCodesAlreadyShown = false; // Track if pack codes page has been shown to prevent re-rendering
        let pollingInterval = null; // Track polling interval for cleanup

        // DOM Elements
        const joinCreateSection = document.getElementById('join-create-section');
        const lobbySection = document.getElementById('lobby-section');
        const playerGridSection = document.getElementById('player-grid-section');
        const packCodesSection = document.getElementById('pack-codes-section');
        const sessionInfo = document.getElementById('session-info');
        const sessionCodeDisplay = document.getElementById('session-code-display');
        const enterNameSection = document.getElementById('enter-name-section');
        const createSessionBtn = document.getElementById('create-session-btn');
        const joinSessionBtn = document.getElementById('join-session-btn');
        const joinCodeInput = document.getElementById('join-code-input');
        const confirmNameBtn = document.getElementById('confirm-name-btn');
        const playerNameInput = document.getElementById('player-name-input');
        const tempSessionCode = document.getElementById('temp-session-code');
        const rollPerksBtn = document.getElementById('roll-perks-btn');
        const copySessionCodeBtn = document.getElementById('copy-session-code');
        const leaveSessionBtn = document.getElementById('leave-session');
        const statusMessage = document.getElementById('status-message');

        async function init() {
            console.log('üéÆ [INIT] Starting game mode initialization...');
            try {
                showStatus('Loading...');
                
                // Initialize managers
                console.log('üéÆ [INIT] Creating SessionManager...');
                sessionManager = new SessionManager();
                
                console.log('üéÆ [INIT] Creating PerkLoader...');
                perkLoader = new PerkLoader();
                
                console.log('üéÆ [INIT] Creating PackConfigGenerator...');
                packConfigGenerator = new PackConfigGenerator();
                
                // Load perks
                console.log('üì¶ [INIT] Loading perks data...');
                perksData = await perkLoader.loadPerks();
                console.log('‚úÖ [INIT] Perks loaded:', perksData.length, 'perks');
                
                // Load CSV data for randomizer
                console.log('üìä [INIT] Loading CSV data...');
                await getCsvInfo();
                console.log('‚úÖ [INIT] CSV data loaded');
                
                // Initialize game mode controller
                console.log('üéÆ [INIT] Creating GameModeController...');
                gameModeController = new GameModeController(
                    sessionManager,
                    perkLoader,
                    packConfigGenerator
                );
                console.log('‚úÖ [INIT] GameModeController created');
                
                // Initialize perk reveal controller
                console.log('‚ú® [INIT] Creating PerkRevealController...');
                perkRevealController = new PerkRevealController();
                console.log('‚úÖ [INIT] PerkRevealController created');
                
                // Wire up perk reveal control buttons
                console.log('üîò [INIT] Setting up perk reveal controls...');
                const continueHandler = () => {
                    console.log('‚û°Ô∏è [REVEAL] Continue button clicked');
                    perkRevealController.continue();
                };
                document.getElementById('perk-reveal-continue').addEventListener('click', continueHandler);
                document.getElementById('perk-reveal-continue-top').addEventListener('click', continueHandler);
                console.log('‚úÖ [INIT] Perk reveal controls ready');
                
                console.log('‚úÖ [INIT] Initialization complete!');
                showStatus('Ready! Create or join a session.');
                
                // Check for session code in URL
                checkURLParameters();
            } catch (error) {
                console.error('‚ùå [INIT] Initialization error:', error);
                showStatus('Error loading. Please refresh the page.');
            }
        }

        // Check URL parameters for direct session joining
        async function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionCode = urlParams.get('session');
            
            if (sessionCode) {
                console.log('üîó [URL] Session code found in URL:', sessionCode);
                
                // Check if we have a stored player ID for this session
                const storedPlayerId = sessionManager.getPlayerIdFromStorage(sessionCode);
                
                if (storedPlayerId) {
                    console.log('üîÑ [URL] Found stored player ID, attempting to rejoin...');
                    try {
                        showStatus('Reconnecting to session...');
                        const result = await sessionManager.rejoinSession(sessionCode, storedPlayerId);
                        console.log('‚úÖ [URL] Rejoined session:', result);
                        
                        currentSession = result.sessionData;
                        currentPlayerId = result.playerId;
                        
                        // Sync gameModeController
                        gameModeController.currentSession = currentSession;
                        gameModeController.currentPlayerId = currentPlayerId;
                        
                        // Navigate to appropriate screen based on session state
                        if (currentSession.state === 'waiting') {
                            enterLobby();
                        } else if (currentSession.state === 'selecting') {
                            // Check if player has seen perks
                            const currentPlayer = currentSession.players.find(p => p.id === currentPlayerId);
                            if (currentPlayer && !currentPlayer.hasSeenPerks) {
                                showPerkReveal(currentSession);
                            } else {
                                // Already seen perks, go straight to game mode
                                enterGameMode();
                                // Start polling for updates
                                startPolling();
                            }
                        } else if (currentSession.state === 'complete') {
                            // Game is complete, go to pack codes
                            // First enter game mode to set up the grid, then show pack codes
                            enterGameMode();
                            // Start polling for updates
                            startPolling();
                            // Use setTimeout to ensure grid is rendered first
                            setTimeout(() => {
                                showPackCodes();
                            }, 100);
                        }
                        
                        showStatus('Reconnected successfully!');
                        return;
                    } catch (error) {
                        console.error('‚ùå [URL] Rejoin failed:', error);
                        // Fall through to normal join
                        showStatus('Could not reconnect, please join manually');
                    }
                }
                
                // Normal join flow
                joinCodeInput.value = sessionCode.toUpperCase();
                // Automatically trigger join
                joinSessionBtn.click();
            }
        }

        // Event Listeners
        createSessionBtn.addEventListener('click', async () => {
            console.log('üé≤ [CREATE] Create session button clicked');
            
            try {
                showStatus('Creating session...');
                
                // Get perks count from input (default 6)
                const perksCountInput = document.getElementById('create-perks-count');
                const perksCount = perksCountInput ? parseInt(perksCountInput.value) || 6 : 6;
                
                // Get Avatar Mode checkbox
                const avatarModeCheckbox = document.getElementById('create-avatar-mode');
                const avatarMode = avatarModeCheckbox ? avatarModeCheckbox.checked : false;
                
                console.log('üì° [CREATE] Calling sessionManager.createSession()...');
                console.log('üéÆ [CREATE] Perks count:', perksCount, '| Avatar Mode:', avatarMode);
                const result = await sessionManager.createSession('', perksCount, avatarMode); // Empty name initially, pass perks count and avatar mode
                console.log('‚úÖ [CREATE] Session created:', result);
                
                currentSession = result.sessionData;
                currentPlayerId = result.playerId;
                console.log('üíæ [CREATE] Stored session:', currentSession.sessionCode, 'playerId:', currentPlayerId);
                
                // Update URL with session code
                const url = new URL(window.location);
                url.searchParams.set('session', currentSession.sessionCode);
                window.history.pushState({}, '', url);
                
                showEnterNameScreen();
            } catch (error) {
                console.error('‚ùå [CREATE] Create session error:', error);
                showStatus('Failed to create session. Please try again.');
            }
        });

        joinSessionBtn.addEventListener('click', async () => {
            const code = joinCodeInput.value.trim().toUpperCase();
            console.log('üé≤ [JOIN] Join session button clicked, code:', code);
            
            if (!code || code.length !== 5) {
                console.warn('‚ö†Ô∏è [JOIN] Invalid session code');
                showStatus('Please enter a valid 5-character session code.');
                return;
            }
            
            try {
                showStatus('Joining session...');
                
                // Check if we have a stored player ID for this session (rejoining)
                const storedPlayerId = sessionManager.getPlayerIdFromStorage(code);
                
                let result;
                if (storedPlayerId) {
                    console.log('ÔøΩ [JOIN] Found stored player ID, attempting rejoin...');
                    try {
                        result = await sessionManager.rejoinSession(code, storedPlayerId);
                        console.log('‚úÖ [JOIN] Rejoined session with existing player ID:', result);
                        
                        currentSession = result.sessionData;
                        currentPlayerId = result.playerId;
                        
                        // Update URL with session code
                        const url = new URL(window.location);
                        url.searchParams.set('session', currentSession.sessionCode);
                        window.history.pushState({}, '', url);
                        
                        // Route to appropriate screen based on session state and player state
                        const currentPlayer = currentSession.players.find(p => p.id === currentPlayerId);
                        
                        // Always set gameModeController state
                        gameModeController.currentSession = currentSession;
                        gameModeController.currentPlayerId = currentPlayerId;
                        
                        if (currentSession.state === 'complete') {
                            // Show pack codes
                            enterGameMode();
                            startPolling();
                            setTimeout(() => {
                                showPackCodes();
                            }, 100);
                        } else if (currentSession.state === 'selecting') {
                            // Check if player needs to see perk reveal
                            if (currentPlayer && !currentPlayer.hasSeenPerks) {
                                showPerkReveal(currentSession);
                            } else {
                                // Go to commander selection
                                enterGameMode();
                                startPolling();
                            }
                        } else if (currentSession.state === 'waiting') {
                            // Go to lobby
                            enterLobby();
                        } else {
                            // Default to lobby
                            enterLobby();
                        }
                        
                        return;
                    } catch (rejoinError) {
                        console.warn('‚ö†Ô∏è [JOIN] Rejoin failed, falling back to new join:', rejoinError);
                        // Fall through to normal join
                    }
                }
                
                console.log('üì° [JOIN] Calling sessionManager.joinSession()...');
                result = await sessionManager.joinSession(code, ''); // Empty name initially
                console.log('‚úÖ [JOIN] Joined session:', result);
                
                currentSession = result.sessionData;
                currentPlayerId = result.playerId;
                console.log('üíæ [JOIN] Stored session:', currentSession.sessionCode, 'playerId:', currentPlayerId);
                
                // Update URL with session code
                const url = new URL(window.location);
                url.searchParams.set('session', currentSession.sessionCode);
                window.history.pushState({}, '', url);
                
                showEnterNameScreen();
            } catch (error) {
                console.error('‚ùå [JOIN] Join session error:', error);
                showStatus('Failed to join session. Check the code and try again.');
            }
        });

        confirmNameBtn.addEventListener('click', async () => {
            const playerName = playerNameInput.value.trim();
            console.log('‚úÖ [NAME] Confirm name clicked:', playerName);
            
            // Allow empty name - API will generate default "Player N"
            
            try {
                showStatus('Updating name...');
                console.log('üì° [NAME] Calling sessionManager.updatePlayerName()...');
                const updatedSession = await sessionManager.updatePlayerName(playerName);
                console.log('‚úÖ [NAME] Name updated:', updatedSession);
                
                currentSession = updatedSession;
                enterLobby();
            } catch (error) {
                console.error('‚ùå [NAME] Update name error:', error);
                showStatus('Failed to update name. Please try again.');
            }
        });

        // Allow Enter key to confirm name
        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                confirmNameBtn.click();
            }
        });

        function showEnterNameScreen() {
            console.log('üìù [NAME] Showing enter name screen');
            hideAllPages();
            enterNameSection.classList.remove('hidden');
            sessionInfo.classList.remove('hidden');
            tempSessionCode.textContent = currentSession.sessionCode;
            playerNameInput.value = '';
            playerNameInput.focus();
            showStatus('');
        }

        rollPerksBtn.addEventListener('click', async () => {
            console.log('üé≤ [PERKS] Roll perks button clicked');
            try {
                showStatus('Rolling perks...');
                console.log('üì° [PERKS] Calling sessionManager.rollPerks()...');
                const session = await sessionManager.rollPerks(
                    currentSession.sessionCode,
                    currentPlayerId
                );
                console.log('‚úÖ [PERKS] Perks rolled:', session);
                
                currentSession = session;
                console.log('üíæ [PERKS] Updated session state');
                
                // Show perk reveal animation instead of going directly to game mode
                showPerkReveal(session);
            } catch (error) {
                console.error('‚ùå [PERKS] Roll perks error:', error);
                showStatus('Failed to roll perks. Please try again.');
            }
        });

        copySessionCodeBtn.addEventListener('click', () => {
            console.log('üìã [COPY] Copy session code clicked');
            navigator.clipboard.writeText(currentSession.sessionCode);
            console.log('‚úÖ [COPY] Copied:', currentSession.sessionCode);
            showStatus('Session code copied!');
        });

        leaveSessionBtn.addEventListener('click', () => {
            console.log('üö™ [LEAVE] Leave session clicked');
            
            const isHost = currentSession && currentSession.hostId === currentPlayerId;
            const message = isHost 
                ? 'Are you sure you want to leave?\n\nAs the host, this will end the session for everyone.'
                : 'Are you sure you want to leave the session?\n\nYou can rejoin later using the same session code.';
            
            if (confirm(message)) {
                console.log('‚úÖ [LEAVE] User confirmed');
                
                // Stop polling
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    console.log('üö™ [LEAVE] Stopped polling');
                }
                
                // Clear current session
                currentSession = null;
                currentPlayerId = null;
                
                // Navigate back to home screen
                console.log('üö™ [LEAVE] Returning to home screen');
                window.history.pushState({}, document.title, window.location.pathname);
                location.reload();
            } else {
                console.log('‚ùå [LEAVE] User cancelled');
            }
        });

        // Force Advance button (host only)
        const forceAdvanceBtn = document.getElementById('force-advance-btn');
        if (forceAdvanceBtn) {
            forceAdvanceBtn.addEventListener('click', async () => {
                console.log('‚è≠Ô∏è [FORCE] Force advance button clicked');
                
                const isHost = currentSession && currentSession.hostId === currentPlayerId;
                if (!isHost) {
                    showStatus('Only the host can force advance');
                    return;
                }
                
                // Count players who haven't locked in
                const unlockedPlayers = currentSession.players.filter(p => !p.commanderLocked);
                const unlockedCount = unlockedPlayers.length;
                
                if (unlockedCount === 0) {
                    showStatus('All players have already locked in');
                    return;
                }
                
                // Count players who need commanders generated
                const playersNeedingCommanders = unlockedPlayers.filter(p => !p.commanders || p.commanders.length === 0);
                const needsGenCount = playersNeedingCommanders.length;
                
                let confirmMsg = `Force advance to pack codes?\n\n` +
                    `This will automatically select commanders for ${unlockedCount} player(s) who haven't locked in yet.\n\n`;
                
                if (needsGenCount > 0) {
                    confirmMsg += `${needsGenCount} player(s) need commanders generated first (this may take a moment)\n\n`;
                }
                
                confirmMsg += `Continue?`;
                
                if (!confirm(confirmMsg)) {
                    console.log('‚ùå [FORCE] User cancelled');
                    return;
                }
                
                try {
                    // Step 1: Generate commanders for players who don't have any
                    if (playersNeedingCommanders.length > 0) {
                        showStatus(`Generating commanders for ${playersNeedingCommanders.length} player(s)...`);
                        console.log('üé≤ [FORCE] Generating commanders for players:', playersNeedingCommanders.map(p => p.number));
                        
                        for (const player of playersNeedingCommanders) {
                            console.log(`üé≤ [FORCE] Generating commanders for Player ${player.number}...`);
                            
                            // Calculate effects from perks
                            const powerups = player.perks || [];
                            const enrichedPowerups = powerups.map(perk => {
                                const fullPerkData = perksData.find(p => p.id === perk.id);
                                if (fullPerkData) {
                                    return { ...perk, ...fullPerkData };
                                }
                                return perk;
                            });
                            
                            const baseQuantity = 3;
                            const quantityModifier = enrichedPowerups.reduce((sum, p) => sum + (p?.effects?.commanderQuantity || 0), 0);
                            const totalQuantity = baseQuantity + quantityModifier;
                            
                            const allEffects = {
                                commanderQuantity: quantityModifier,
                                distributionShift: enrichedPowerups.reduce((sum, p) => sum + (p?.effects?.distributionShift || 0), 0),
                                saltMode: enrichedPowerups.find(p => p?.effects?.saltMode)?.effects?.saltMode || null
                            };
                            
                            // Get avatar mode setting
                            const gameModeOptions = {
                                avatarMode: currentSession?.settings?.avatarMode || currentSession?.avatarMode || false
                            };
                            
                            // Generate commanders (no color filter for force advance)
                            const commanders = await gameModeController.generateCommandersForPlayer(
                                player.number,
                                allEffects,
                                null, // No color selections for force advance
                                gameModeOptions
                            );
                            
                            console.log(`‚úÖ [FORCE] Generated ${commanders.length} commanders for Player ${player.number}`);
                            
                            // Update session with generated commanders (force=true to override already generated check)
                            await sessionManager.updateCommanders(commanders, null, true);
                        }
                    }
                    
                    // Step 2: Force advance to pack codes
                    showStatus('Advancing to pack codes...');
                    const result = await sessionManager.forceAdvance();
                    console.log('‚úÖ [FORCE] Force advance successful:', result);
                    currentSession = result;
                    showPackCodes();
                } catch (error) {
                    console.error('‚ùå [FORCE] Force advance error:', error);
                    showStatus('Failed to force advance: ' + error.message);
                }
            });
        }

        // Kick player from lobby
        // Kick player from lobby (expose to global scope for onclick)
        window.kickPlayerFromLobby = async function(playerId, playerName) {
            console.log('üë¢ [KICK] Kick player clicked:', playerId, playerName);
            
            if (!confirm(`Kick ${playerName} from the session?\n\nThey will be able to rejoin if they want.`)) {
                console.log('‚ùå [KICK] User cancelled');
                return;
            }
            
            try {
                showStatus('Kicking player...');
                const result = await sessionManager.kickPlayer(playerId);
                console.log('‚úÖ [KICK] Player kicked:', result);
                currentSession = result.sessionData;
                updateLobbyPlayers();
                showStatus(`${playerName} has been removed from the session`);
            } catch (error) {
                console.error('‚ùå [KICK] Kick error:', error);
                showStatus('Failed to kick player: ' + error.message);
            }
        }

        // Kick player from game mode (commander selection) (expose to global scope for onclick)
        window.kickPlayerFromGame = async function(playerId, playerName) {
            console.log('üë¢ [KICK] Kick player from game clicked:', playerId, playerName);
            
            if (!confirm(`Kick ${playerName} from the session?\n\nThey will be able to rejoin if they want.`)) {
                console.log('‚ùå [KICK] User cancelled');
                return;
            }
            
            try {
                showStatus('Kicking player...');
                const result = await sessionManager.kickPlayer(playerId);
                console.log('‚úÖ [KICK] Player kicked:', result);
                currentSession = result.sessionData;
                gameModeController.currentSession = currentSession;
                renderPlayerGrid();
                showStatus(`${playerName} has been removed from the session`);
            } catch (error) {
                console.error('‚ùå [KICK] Kick error:', error);
                showStatus('Failed to kick player: ' + error.message);
            }
        }

        function enterLobby() {
            console.log('üö™ [LOBBY] Entering lobby...');
            hideAllPages();
            lobbySection.classList.remove('hidden');
            sessionInfo.classList.remove('hidden');
            sessionCodeDisplay.textContent = currentSession.sessionCode;
            
            // Update controller
            console.log('üîÑ [LOBBY] Updating controller state');
            gameModeController.currentSession = currentSession;
            gameModeController.currentPlayerId = currentPlayerId;
            
            updateLobbyPlayers();
            
            // Show roll button only for host
            const isHost = currentSession.hostId === currentPlayerId;
            console.log('üëë [LOBBY] Is host:', isHost);
            rollPerksBtn.style.display = isHost ? 'block' : 'none';
            
            // Start polling
            console.log('üîÑ [LOBBY] Starting session polling');
            startPolling();
            console.log('‚úÖ [LOBBY] Lobby entered successfully');
        }

        function updateLobbyPlayers() {
            const lobbyPlayers = document.getElementById('lobby-players');
            lobbyPlayers.innerHTML = '';
            
            const isHost = currentSession && currentSession.hostId === currentPlayerId;
            
            // Filter out kicked players for display
            const activePlayers = currentSession.players.filter(p => !p.isKicked);
            
            for (let i = 0; i < 4; i++) {
                const player = activePlayers[i];
                const div = document.createElement('div');
                div.className = 'lobby-player' + (player ? ' active' : '');
                
                if (player) {
                    const isYou = player.id === currentPlayerId;
                    const isPlayerHost = player.id === currentSession.hostId;
                    
                    // Show kick button for host (not on their own card)
                    const kickButton = (isHost && !isYou) 
                        ? `<button class="kick-btn" onclick="kickPlayerFromLobby('${player.id}', '${player.name || 'Player ' + player.number}')">‚ùå Kick</button>`
                        : '';
                    
                    div.innerHTML = `
                        <div style="flex: 1;">
                            <strong>${player.name || `Player ${player.number}`}</strong>
                            ${isYou ? '<br>(You)' : ''}
                            ${isPlayerHost ? '<br>üëë Host' : ''}
                        </div>
                        ${kickButton}
                    `;
                } else {
                    div.innerHTML = '<em>Waiting...</em>';
                }
                
                lobbyPlayers.appendChild(div);
            }
        }

        function hideAllPages() {
            console.log('üôà [PAGES] Hiding all pages');
            document.getElementById('join-create-section')?.classList.add('hidden');
            document.getElementById('enter-name-section')?.classList.add('hidden');
            document.getElementById('lobby-section')?.classList.add('hidden');
            document.getElementById('perk-reveal-page')?.classList.remove('active');
            document.getElementById('player-grid-section')?.classList.add('hidden');
            document.getElementById('pack-codes-section')?.classList.add('hidden');
        }

        function showPerkReveal(session) {
            console.log('‚ú® [REVEAL] Showing perk reveal page');
            const currentPlayer = session.players.find(p => p.id === currentPlayerId);
            
            if (!currentPlayer || !currentPlayer.perks) {
                console.log('‚ö†Ô∏è [REVEAL] No perks found, proceeding to commander selection');
                proceedToCommanderSelection(session);
                return;
            }
            
            // Check if player has already seen perks (e.g., after refresh/rejoin)
            if (currentPlayer.hasSeenPerks) {
                console.log('üëÅÔ∏è [REVEAL] Player already seen perks, skipping reveal');
                proceedToCommanderSelection(session);
                return;
            }
            
            console.log('üé¥ [REVEAL] Starting reveal for', currentPlayer.perks.length, 'perks');
            console.log('üîç [REVEAL] Perk data:', currentPlayer.perks);
            
            // Enrich perks with full data from perksData
            const enrichedPerks = currentPlayer.perks.map(perk => {
                const fullPerkData = perksData.find(p => p.id === perk.id);
                if (fullPerkData) {
                    console.log('‚úÖ [REVEAL] Enriched perk:', perk.name, 'with extended_description:', fullPerkData.extended_description);
                    return { ...perk, ...fullPerkData };
                }
                console.warn('‚ö†Ô∏è [REVEAL] No full data found for perk:', perk.id);
                return perk;
            });
            
            hideAllPages();
            document.getElementById('perk-reveal-page').classList.add('active');
            
            perkRevealController.startReveal(enrichedPerks, async () => {
                console.log('‚úÖ [REVEAL] Reveal complete, proceeding to commander selection');
                
                // Mark perks as seen on backend
                try {
                    await sessionManager.markPerksSeen();
                    console.log('üëÅÔ∏è [REVEAL] Marked perks as seen on backend');
                } catch (error) {
                    console.warn('‚ö†Ô∏è [REVEAL] Failed to mark perks as seen:', error);
                }
                
                proceedToCommanderSelection(session);
            });
        }

        function proceedToCommanderSelection(session) {
            console.log('‚û°Ô∏è [PROCEED] Proceeding to commander selection');
            document.getElementById('perk-reveal-page').classList.remove('active');
            currentSession = session;
            gameModeController.currentSession = session;
            gameModeController.currentPlayerId = currentPlayerId;
            enterGameMode();
        }

        function validateSessionState() {
            // Helper to ensure session state is consistent
            if (!currentSession) {
                console.error('‚ùå [STATE] No current session!');
                return false;
            }
            if (!currentPlayerId) {
                console.error('‚ùå [STATE] No current player ID!');
                return false;
            }
            if (!gameModeController.currentSession) {
                console.warn('‚ö†Ô∏è [STATE] GameModeController session out of sync, fixing...');
                gameModeController.currentSession = currentSession;
                gameModeController.currentPlayerId = currentPlayerId;
            }
            return true;
        }

        function normalizeCommanderData(commander) {
            // Normalize commander data to handle both fresh generation and backend storage
            return {
                name: commander.name,
                rank: commander.rank,
                edhrec_url: commander.edhrec_url || commander.edhrecUrl,
                image_url: commander.image_url || commander.imageUrl || commander.image,
                image: commander.image || commander.imageUrl || commander.image_url,
                imageUrl: commander.imageUrl || commander.image_url || commander.image
            };
        }

        function enterGameMode() {
            hideAllPages();
            playerGridSection.classList.remove('hidden');
            
            // Ensure gameModeController has current session
            gameModeController.currentSession = currentSession;
            gameModeController.currentPlayerId = currentPlayerId;
            
            renderPlayerGrid();
        }

        function renderPlayerGrid() {
            const playerGrid = document.getElementById('player-grid');
            playerGrid.innerHTML = '';
            
            // Filter out kicked players for display
            const activePlayers = currentSession.players.filter(player => !player.isKicked);
            
            activePlayers.forEach(player => {
                // Populate gameModeController with existing commanders from backend
                if (player.commanders && player.commanders.length > 0) {
                    // Normalize commander data to ensure consistent field names
                    gameModeController.playerCommanderData[player.number] = player.commanders.map(normalizeCommanderData);
                    
                    // Restore selected commander index if player was selecting
                    if (player.selectedCommanderIndex !== undefined && player.selectedCommanderIndex !== null) {
                        gameModeController.playerSelectedCommander[player.number] = player.selectedCommanderIndex;
                        console.log(`üîÑ [RENDER] Restored selection for P${player.number}: index ${player.selectedCommanderIndex}`);
                    }
                }
                
                const isCurrentPlayer = player.id === currentPlayerId;
                const section = createPlayerSection(player, isCurrentPlayer);
                playerGrid.appendChild(section);
            });
            
            // Show/hide force advance button (host only)
            const forceAdvanceBtn = document.getElementById('force-advance-btn');
            const isHost = currentSession && currentSession.hostId === currentPlayerId;
            if (forceAdvanceBtn) {
                forceAdvanceBtn.classList.toggle('hidden', !isHost);
            }
            
            // Attach color filter event listeners
            attachColorFilterListeners();
        }

        function updatePlayerStatuses() {
            // Check if all active players have sections - if not, force full re-render
            const activePlayers = currentSession.players.filter(p => !p.isKicked);
            const missingSections = activePlayers.some(player => !document.getElementById(`player-${player.number}`));
            
            if (missingSections) {
                console.log('üîÑ [UPDATE] Missing player sections detected - forcing full re-render');
                renderPlayerGrid();
                return;
            }
            
            // Check if any player's perk visibility changed (need to re-render to show actual perks)
            const perkVisibilityChanged = activePlayers.some(player => {
                const playerSection = document.getElementById(`player-${player.number}`);
                if (!playerSection) return false;
                
                const hasPlaceholder = playerSection.querySelector('.perks-rolling-placeholder');
                const hasActualPerks = playerSection.querySelector('.powerups-container');
                const shouldShowPerks = player.hasSeenPerks || player.id === currentPlayerId;
                
                // Need re-render if: showing placeholder but should show perks, or vice versa
                return (hasPlaceholder && shouldShowPerks) || (hasActualPerks && !shouldShowPerks);
            });
            
            if (perkVisibilityChanged) {
                console.log('üîÑ [UPDATE] Perk visibility changed - forcing full re-render');
                renderPlayerGrid();
                return;
            }
            
            // Update only the status indicators without re-rendering the entire grid
            currentSession.players.forEach(player => {
                const playerSection = document.getElementById(`player-${player.number}`);
                if (!playerSection) return;
                
                const playerStatus = playerSection.querySelector('.player-status');
                if (playerStatus) {
                    if (player.commanderLocked) {
                        playerStatus.textContent = 'üîí Locked';
                    } else {
                        playerStatus.textContent = 'Selecting...';
                    }
                }
                
                // Update locked class
                if (player.commanderLocked) {
                    playerSection.classList.add('locked');
                } else {
                    playerSection.classList.remove('locked');
                }
                
                // Update color filter selections from session data
                if (player.colorSelections && player.colorSelections.selected) {
                    const colorFilterContainer = playerSection.querySelector('.color-filter-checkboxes');
                    if (colorFilterContainer) {
                        const selectedColors = player.colorSelections.selected;
                        const checkboxes = colorFilterContainer.querySelectorAll('.color-input');
                        
                        checkboxes.forEach(checkbox => {
                            const shouldBeChecked = selectedColors.includes(checkbox.value);
                            if (checkbox.checked !== shouldBeChecked) {
                                checkbox.checked = shouldBeChecked;
                            }
                        });
                    }
                }
                
                // Sync commanders from other players if they generated them
                const commandersGrid = document.getElementById(`commanders-${player.number}`);
                if (commandersGrid && player.commanders && player.commanders.length > 0) {
                    // Mark this player as having generated commanders
                    const wasGenerated = playerCommandersGenerated[player.number];
                    playerCommandersGenerated[player.number] = true;
                    
                    // If player is locked, show only locked commander
                    if (player.commanderLocked) {
                        const alreadyShowingLocked = commandersGrid.querySelector('.commander-item-small.locked');
                        const alreadyShowingCorrectLocked = commandersGrid.querySelector(`#commander-${player.number}-${player.selectedCommanderIndex}.locked`);
                        
                        if (!alreadyShowingCorrectLocked) {
                            console.log(`üîí [UPDATE] Player ${player.number} is locked - showing locked commander (had locked: ${!!alreadyShowingLocked}, correct: ${!!alreadyShowingCorrectLocked})`);
                            commandersGrid.innerHTML = renderExistingCommanders(player);
                        }
                    }
                    // If not locked, check if we need to render commanders
                    else {
                        const isEmpty = commandersGrid.querySelector('em') || commandersGrid.children.length === 0;
                        const hasWrongPlayerCommanders = !commandersGrid.querySelector(`#commander-${player.number}-0`);
                        const justGenerated = !wasGenerated && playerCommandersGenerated[player.number];
                        
                        // Render if empty OR if showing wrong player's commanders (after rejoin) OR just generated
                        if (isEmpty || hasWrongPlayerCommanders || justGenerated) {
                            console.log(`üîÑ [UPDATE] Player ${player.number} commanders need rendering (empty: ${isEmpty}, wrong: ${hasWrongPlayerCommanders}, justGenerated: ${justGenerated})`);
                            commandersGrid.innerHTML = renderExistingCommanders(player);
                            
                            // Restore checkbox state if there was a selection
                            if (player.selectedCommanderIndex !== undefined && player.selectedCommanderIndex !== null) {
                                const checkbox = commandersGrid.querySelector(`input[name="commander-select-${player.number}"]:nth-of-type(${player.selectedCommanderIndex + 1})`);
                                if (checkbox) {
                                    checkbox.checked = true;
                                    const item = document.getElementById(`commander-${player.number}-${player.selectedCommanderIndex}`);
                                    if (item) item.classList.add('selected');
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPlayerSection(player, isCurrentPlayer) {
            const section = document.createElement('div');
            section.className = 'player-section';
            section.id = `player-${player.number}`;
            
            if (isCurrentPlayer) {
                section.classList.add('current-player');
            }
            
            if (player.commanderLocked) {
                section.classList.add('locked');
            }
            
            // Get powerups (now an array)
            const powerups = player.perks || (player.perk ? [player.perk] : []);
            
            // Enrich powerups with full perk data (including emoji)
            const enrichedPowerups = powerups.map(perk => {
                const fullPerkData = perksData.find(p => p.id === perk.id);
                if (fullPerkData) {
                    return { ...perk, ...fullPerkData };
                }
                return perk;
            });
            
            // Sort powerups by rarity (common -> uncommon -> rare -> mythic)
            const raritySortOrder = { common: 1, uncommon: 2, rare: 3, mythic: 4 };
            const sortedPowerups = [...enrichedPowerups].sort((a, b) => {
                const rarityA = raritySortOrder[a?.rarity || 'common'] || 1;
                const rarityB = raritySortOrder[b?.rarity || 'common'] || 1;
                return rarityA - rarityB;
            });
            
            // Calculate total commander quantity from all powerups
            const baseQuantity = 3;
            const quantityModifier = sortedPowerups.reduce((sum, p) => sum + (p?.effects?.commanderQuantity || 0), 0);
            const totalQuantity = baseQuantity + quantityModifier;
            
            // Collect all powerup effects into a single object
            const allEffects = {
                commanderQuantity: quantityModifier
            };
            
            // Collect all color filter effects
            const colorEffects = sortedPowerups.map(p => p?.effects).filter(e => e?.colorFilterMode);
            const primaryColorEffect = colorEffects[0] || null;
            
            // Merge color filter into allEffects if present
            if (primaryColorEffect?.colorFilterMode) {
                allEffects.colorFilterMode = primaryColorEffect.colorFilterMode;
                allEffects.colorFilterCount = primaryColorEffect.colorFilterCount;
            }
            
            // Render powerups in compact stacked format
            // For other players who haven't seen perks yet, show placeholder
            const hasSeenPerks = player.hasSeenPerks || isCurrentPlayer;
            
            // Calculate exact height to match perks display
            // Each perk: 28px min-height + 0.4rem padding (top+bottom) + 0.3rem margin = ~35px per perk
            const perkHeight = 35;
            const calculatedHeight = sortedPowerups.length * perkHeight;
            
            const powerupsHTML = !hasSeenPerks && sortedPowerups.length > 0 ? `
                <div class="perks-rolling-placeholder" style="min-height: ${calculatedHeight}px;">
                    <div class="spinner"></div>
                    <div class="player-name-label">${player.name || `Player ${player.number}`} still rolling perks</div>
                </div>
            ` : sortedPowerups.length > 0 ? `
                <div class="powerups-container">
                    ${sortedPowerups.map(powerup => {
                        console.log('üîç [DEBUG] Perk data:', powerup);
                        const phaseLabel = powerup.perkPhase === 'commander_selection' ? 'Commander Selection' : 'Drafting';
                        const tooltipText = `${phaseLabel} Perk: ${powerup.description || ''}`;
                        console.log('üîç [DEBUG] Tooltip text:', tooltipText);
                        return `
                        <div class="perk-display ${powerup.rarity || 'common'}" title="${tooltipText}">
                            <span class="perk-name">${powerup.emoji ? powerup.emoji + ' ' : ''}${powerup.name || 'Unknown'}</span>
                            <span class="perk-rarity">${powerup.rarity || 'common'}</span>
                        </div>
                    `}).join('')}
                </div>
            ` : '';
            
            section.innerHTML = `
                <div class="player-header">
                    <span class="player-number">${player.name || `Player ${player.number}`}${isCurrentPlayer ? ' (You)' : ''}</span>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        ${!isCurrentPlayer && currentSession.hostId === currentPlayerId ? `
                            <button class="kick-btn" style="font-size: 0.8rem; padding: 0.25rem 0.5rem;" onclick="kickPlayerFromGame('${player.id}', '${player.name || 'Player ' + player.number}')">‚ùå Kick</button>
                        ` : ''}
                        <span class="player-status">${player.commanderLocked ? 'üîí Locked' : 'Selecting...'}</span>
                    </div>
                </div>
                
                ${powerupsHTML}
                
                ${primaryColorEffect?.colorFilterMode ? `
                    <div class="player-settings">
                        ${renderColorFilter(primaryColorEffect, player.number, isCurrentPlayer)}
                    </div>
                ` : ''}
                
                ${isCurrentPlayer && !player.commanderLocked && !player.commandersGenerated ? `
                    <button class="btn btn-primary" id="generate-btn-${player.number}" onclick="generateCommanders(${player.number}, ${totalQuantity}, ${JSON.stringify(allEffects).replace(/"/g, '&quot;')})">
                        üé≤ Generate ${totalQuantity} Commander${totalQuantity > 1 ? 's' : ''}
                    </button>
                ` : ''}
                
                <div class="commander-grid-small" id="commanders-${player.number}">
                    ${player.commanders && player.commanders.length > 0 ? renderExistingCommanders(player) : 
                      player.commanderData ? renderCommanders(player) : 
                      '<em>Waiting for commanders...</em>'}
                </div>
                
                ${isCurrentPlayer && !player.commanderLocked && player.commandersGenerated ? `
                    <button class="btn btn-primary" id="lock-btn-${player.number}" ${player.commanders?.length > 0 ? '' : 'disabled'} onclick="lockCommander(${player.number})">
                        üîí Lock In Commander
                    </button>
                ` : ''}
            `;
            
            return section;
        }

        function renderExistingCommanders(player) {
            const isCurrentPlayer = player.id === currentPlayerId;
            const commanders = player.commanders || [];
            
            if (commanders.length === 0) {
                return '<em>Waiting for commanders...</em>';
            }
            
            // Normalize commander data
            const normalizedCommanders = commanders.map(normalizeCommanderData);
            
            // If player is locked, show only selected commander
            if (player.commanderLocked && player.selectedCommanderIndex !== undefined) {
                const selectedCommander = normalizedCommanders[player.selectedCommanderIndex];
                if (selectedCommander) {
                    return `
                        <div class="commander-item-small selected locked" id="commander-${player.number}-${player.selectedCommanderIndex}">
                            <img src="${selectedCommander.image_url || 'images/card-back.png'}" 
                                 alt="${selectedCommander.name}" 
                                 class="commander-img-small"
                                 data-edhrec-url="${selectedCommander.edhrec_url || ''}"
                                 onclick="openCommanderLink('${selectedCommander.edhrec_url || ''}')"
                                 title="${selectedCommander.name} - LOCKED">
                            <div class="commander-checkbox-container">
                                <label class="commander-checkbox-label">
                                    <input type="checkbox" 
                                           class="commander-checkbox" 
                                           checked 
                                           disabled>
                                    <span class="commander-name-label" title="${selectedCommander.name}">üîí ${selectedCommander.name}</span>
                                </label>
                            </div>
                        </div>
                    `;
                }
            }
            
            // Show all commanders with same structure as fresh generation
            return normalizedCommanders.map((cmd, index) => {
                return `
                    <div class="commander-item-small" id="commander-${player.number}-${index}">
                        <img src="${cmd.image_url || 'images/card-back.png'}" 
                             alt="${cmd.name}" 
                             class="commander-img-small"
                             data-edhrec-url="${cmd.edhrec_url || ''}"
                             onclick="openCommanderLink('${cmd.edhrec_url || ''}')"
                             title="${cmd.name} (Rank: ${cmd.rank})">
                        <div class="commander-checkbox-container">
                            <label class="commander-checkbox-label">
                                <input type="checkbox" 
                                       class="commander-checkbox" 
                                       name="commander-select-${player.number}" 
                                       ${isCurrentPlayer ? '' : 'disabled'}
                                       onchange="selectCommander(${player.number}, ${index}, this)">
                                <span class="commander-name-label" title="${cmd.name}">${cmd.name}</span>
                            </label>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderColorFilter(effects, playerNumber, isCurrentPlayer) {
            if (!effects.colorFilterMode) return '';
            
            const mode = effects.colorFilterMode;
            const count = effects.colorFilterCount || 0;
            const colors = [
                { code: 'W', name: 'white', label: 'W' },
                { code: 'U', name: 'blue', label: 'U' },
                { code: 'B', name: 'black', label: 'B' },
                { code: 'R', name: 'red', label: 'R' },
                { code: 'G', name: 'green', label: 'G' }
            ];
            
            // Add colorless option for exact mode
            if (mode === 'exact') {
                colors.push({ code: 'C', name: 'colorless', label: 'C' });
            }
            
            // Get the player's color selections from session data
            const player = currentSession?.players?.find(p => p.number === playerNumber);
            const selectedColors = player?.colorSelections?.selected || [];
            
            let instruction = '';
            if (mode === 'exclude') instruction = `Select ${count} color${count > 1 ? 's' : ''} to exclude`;
            else if (mode === 'include') instruction = `Select ${count} color${count > 1 ? 's' : ''} to include`;
            else if (mode === 'exact') instruction = 'Select exact colors for your commander (or C for colorless)';
            
            const colorCheckboxes = colors.map(c => {
                const isChecked = selectedColors.includes(c.code);
                return `
                <label class="color-checkbox ${c.name}" ${!isCurrentPlayer ? 'style="pointer-events: none; opacity: 0.7;"' : ''}>
                    <input type="checkbox" value="${c.code}" class="color-input" ${!isCurrentPlayer ? 'disabled' : ''} ${isChecked ? 'checked' : ''}>
                    <span>${c.label}</span>
                </label>
            `}).join('');
            
            return `
                <div class="setting-row">
                    <span class="setting-label">Colors:</span>
                    <div class="color-filter-checkboxes" data-mode="${mode}" data-count="${count}" data-player="${playerNumber}">
                        ${colorCheckboxes}
                    </div>
                </div>
                <div class="setting-row">
                    <small class="color-filter-instruction" style="opacity: 0.7;">${instruction}</small>
                    <small class="color-filter-warning" style="color: #f44336; opacity: 0; transition: opacity 0.3s;">Max ${count} color${count > 1 ? 's' : ''} selected!</small>
                </div>
            `;
        }

        function renderCommanders(player) {
            const isCurrentPlayer = player.id === currentPlayerId;
            
            // Get commanders from session data (sent by the player who generated them)
            let commanders = player.commanders;
            
            // Fall back to local data if available
            if (!commanders || commanders.length === 0) {
                commanders = gameModeController.playerCommanderData[player.number];
            }

            if (!commanders || commanders.length === 0) {
                return '<em>Waiting for commanders...</em>';
            }
            
            // Normalize all commanders to ensure consistent field names
            const normalizedCommanders = commanders.map(normalizeCommanderData);
            
            // If player is locked, show ONLY their selected commander
            if (player.commanderLocked) {
                // Get selected commander index from session or local state
                let selectedIndex = player.selectedCommanderIndex;
                if (selectedIndex === undefined) {
                    selectedIndex = gameModeController.playerSelectedCommander[player.number];
                }
                
                if (selectedIndex !== undefined && normalizedCommanders[selectedIndex]) {
                    const selectedCommander = normalizedCommanders[selectedIndex];
                    // Return ONLY the locked commander in the same grid layout
                    return `
                        <div class="commander-item-small selected locked" id="commander-${player.number}-${selectedIndex}">
                            <img src="${selectedCommander.image_url || 'images/card-back.png'}" 
                                 alt="${selectedCommander.name}" 
                                 class="commander-img-small"
                                 data-edhrec-url="${selectedCommander.edhrec_url || ''}"
                                 onclick="openCommanderLink('${selectedCommander.edhrec_url || ''}')"
                                 title="${selectedCommander.name} (Rank: ${selectedCommander.rank}) - LOCKED">
                            <div class="commander-checkbox-container">
                                <label class="commander-checkbox-label">
                                    <input type="checkbox" 
                                           class="commander-checkbox" 
                                           checked 
                                           disabled>
                                    <span class="commander-name-label" title="${selectedCommander.name}">üîí ${selectedCommander.name}</span>
                                </label>
                            </div>
                        </div>
                    `;
                }
            }
            
            // Not locked - show all commanders
            let html = '';
            normalizedCommanders.forEach((commander, index) => {
                const isSelected = gameModeController.playerSelectedCommander[player.number] === index;
                html += `
                    <div class="commander-item-small ${isSelected ? 'selected' : ''}" id="commander-${player.number}-${index}">
                        <img src="${commander.image_url || 'images/card-back.png'}" 
                             alt="${commander.name}" 
                             class="commander-img-small"
                             data-edhrec-url="${commander.edhrec_url || ''}"
                             onclick="openCommanderLink('${commander.edhrec_url || ''}')"
                             title="${commander.name} (Rank: ${commander.rank})">
                        <div class="commander-checkbox-container">
                            <label class="commander-checkbox-label ${!isCurrentPlayer ? 'other-player' : ''}">
                                ${isCurrentPlayer ? `
                                    <input type="checkbox" 
                                           class="commander-checkbox" 
                                           name="commander-select-${player.number}" 
                                           ${isSelected ? 'checked' : ''}
                                           onchange="selectCommander(${player.number}, ${index}, this)">
                                ` : ''}
                                <span class="commander-name-label" title="${commander.name}">${commander.name}</span>
                            </label>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }

        window.generateCommanders = async function(playerNumber, quantity, effects) {
            console.log(`üé≤ [GEN-P${playerNumber}] Generate commanders clicked - Quantity: ${quantity}, Effects:`, effects);
            
            // Validate session state before proceeding
            if (!validateSessionState()) {
                showStatus('Error: Session state invalid. Please refresh the page.');
                return;
            }
            
            // Find current player and check if they've already generated commanders
            const currentPlayer = currentSession.players.find(p => p.id === currentPlayerId);
            if (!currentPlayer) {
                showStatus('Error: Player not found');
                return;
            }
            
            // Check if commanders have already been generated (prevent refresh cheating)
            if (currentPlayer.commandersGenerated) {
                console.warn(`üö´ [GEN-P${playerNumber}] Commanders already generated - using existing commanders`);
                
                // Display existing commanders from backend
                if (currentPlayer.commanders && currentPlayer.commanders.length > 0) {
                    const commandersGrid = document.getElementById(`commanders-${playerNumber}`);
                    commandersGrid.innerHTML = currentPlayer.commanders.map((cmd, index) => {
                        return `
                            <div class="commander-card">
                                <label>
                                    <input type="checkbox" 
                                           name="commander-select-${playerNumber}" 
                                           onchange="selectCommander(${playerNumber}, ${index}, this)">
                                    <img src="${cmd.image || cmd.imageUrl}" 
                                         alt="${cmd.name}" 
                                         loading="lazy"
                                         onerror="this.src='https://via.placeholder.com/200x280?text=Image+Not+Found'">
                                    <div class="commander-name">${cmd.name}</div>
                                </label>
                            </div>
                        `;
                    }).join('');
                    
                    // Enable lock button
                    const lockBtn = document.getElementById(`lock-btn-${playerNumber}`);
                    if (lockBtn) {
                        lockBtn.disabled = false;
                    }
                    
                    showStatus('Commanders already generated. Select one to lock in.');
                } else {
                    showStatus('Error: Commanders were generated but not found. Please contact support.');
                }
                return;
            }
            
            const playerSection = document.getElementById(`player-${playerNumber}`);
            const commandersGrid = document.getElementById(`commanders-${playerNumber}`);
            const colorFilterContainer = playerSection.querySelector('.color-filter-checkboxes');
            
            // Check if color filter perk is active but no colors selected
            if (colorFilterContainer) {
                const mode = colorFilterContainer.dataset.mode;
                const checkedInputs = colorFilterContainer.querySelectorAll('.color-input:checked');
                
                if (checkedInputs.length === 0) {
                    const modeNames = {
                        'exclude': 'Exclude Color',
                        'include': 'Include Color',
                        'exact': 'Exact Color Selection'
                    };
                    const modeName = modeNames[mode] || 'Color Filter';
                    
                    const confirmed = confirm(
                        `‚ö†Ô∏è You have the "${modeName}" perk but haven't selected any colors.\n\n` +
                        `This means you'll get a random commander from the entire pool.\n\n` +
                        `Do you want to continue without using your color filter perk?`
                    );
                    
                    if (!confirmed) {
                        console.log(`‚ùå [GEN-P${playerNumber}] User cancelled - no colors selected for color filter perk`);
                        return;
                    }
                }
            }
            
            showStatus(`Generating ${quantity} commanders for Player ${playerNumber}...`);
            
            try {
                // Get color selections from UI if applicable
                console.log(`üé® [GEN-P${playerNumber}] Checking for color filter selections...`);
                const colorSelections = gameModeController.getColorSelectionsFromUI(colorFilterContainer);
                console.log(`üé® [GEN-P${playerNumber}] Color selections:`, colorSelections);
                
                // Get Avatar Mode setting from session (if host set it during creation)
                console.log(`üîç [GEN-P${playerNumber}] Current session:`, currentSession);
                console.log(`üîç [GEN-P${playerNumber}] Session.settings:`, currentSession?.settings);
                const gameModeOptions = {
                    avatarMode: currentSession?.settings?.avatarMode || currentSession?.avatarMode || false
                };
                console.log(`üéÆ [GEN-P${playerNumber}] Game mode options:`, gameModeOptions);
                console.log(`üéÆ [GEN-P${playerNumber}] Avatar Mode: ${gameModeOptions.avatarMode ? 'ENABLED ‚úÖ' : 'DISABLED ‚ùå'}`);
                
                // Generate commanders
                console.log(`üì° [GEN-P${playerNumber}] Calling generateCommandersForPlayer...`);
                const commanders = await gameModeController.generateCommandersForPlayer(
                    playerNumber,
                    effects,
                    colorSelections,
                    gameModeOptions
                );
                console.log(`‚úÖ [GEN-P${playerNumber}] Generated ${commanders.length} commanders:`, commanders);
                
                // Render commanders in grid
                console.log(`üé® [GEN-P${playerNumber}] Rendering commander grid...`);
                commandersGrid.innerHTML = '';
                commanders.forEach((commander, index) => {
                    const item = document.createElement('div');
                    item.className = 'commander-item-small';
                    item.id = `commander-${playerNumber}-${index}`;
                    
                    item.innerHTML = `
                        <img src="${commander.image_url || 'images/card-back.png'}" 
                             alt="${commander.name}" 
                             class="commander-img-small"
                             data-edhrec-url="${commander.edhrec_url || ''}"
                             onclick="openCommanderLink('${commander.edhrec_url || ''}')"
                             title="${commander.name} (Rank: ${commander.rank})">
                        <div class="commander-checkbox-container">
                            <label class="commander-checkbox-label">
                                <input type="checkbox" 
                                       class="commander-checkbox" 
                                       name="commander-select-${playerNumber}" 
                                       onchange="selectCommander(${playerNumber}, ${index}, this)">
                                <span class="commander-name-label" title="${commander.name}">${commander.name}</span>
                            </label>
                        </div>
                    `;
                    
                    commandersGrid.appendChild(item);
                });
                
                console.log(`‚úÖ [GEN-P${playerNumber}] Commander grid rendered`);
                showStatus(`Generated ${commanders.length} commanders for Player ${playerNumber}`);
                
                // Store commanders in gameModeController for lock functionality
                gameModeController.playerCommanderData[playerNumber] = commanders;
                
                // Mark player as having generated commanders
                playerCommandersGenerated[playerNumber] = true;
                console.log(`üìù [GEN-P${playerNumber}] Marked as generated, state:`, playerCommandersGenerated);
                
                // Hide the generate button and show the lock button
                const generateBtn = document.getElementById(`generate-btn-${playerNumber}`);
                if (generateBtn) {
                    generateBtn.style.display = 'none';
                }
                
                // Show the lock button if it doesn't exist
                const playerSection = document.getElementById(`player-${playerNumber}`);
                let lockBtn = document.getElementById(`lock-btn-${playerNumber}`);
                if (!lockBtn && playerSection) {
                    console.log(`üîì [GEN-P${playerNumber}] Creating lock button...`);
                    lockBtn = document.createElement('button');
                    lockBtn.className = 'btn btn-primary';
                    lockBtn.id = `lock-btn-${playerNumber}`;
                    lockBtn.disabled = true;
                    lockBtn.onclick = () => lockCommander(playerNumber);
                    lockBtn.textContent = 'üîí Lock In Commander';
                    playerSection.appendChild(lockBtn);
                }
                
                // Send commanders to server in background (don't await - let it happen async)
                console.log(`üì° [GEN-P${playerNumber}] Syncing commanders to server...`);
                sessionManager.updateCommanders(commanders, colorSelections)
                    .then((updatedSession) => {
                        console.log(`‚úÖ [GEN-P${playerNumber}] Commanders synced to server`);
                        
                        // Update session state from backend response
                        if (updatedSession) {
                            currentSession = updatedSession;
                            gameModeController.currentSession = updatedSession;
                            
                            const player = updatedSession.players.find(p => p.id === currentPlayerId);
                            if (player) {
                                console.log(`‚úÖ [GEN-P${playerNumber}] Backend confirmed: commandersGenerated=${player.commandersGenerated}`);
                            }
                        }
                    })
                    .catch(error => {
                        console.error(`‚ùå [GEN-P${playerNumber}] Failed to sync commanders:`, error.message);
                        
                        // If backend rejected (e.g., already generated), show error
                        if (error.message.includes('already generated')) {
                            showStatus('‚ö†Ô∏è Commanders already generated. Cannot regenerate.');
                            // Hide the generate button
                            const generateBtn = document.getElementById(`gen-btn-${playerNumber}`);
                            if (generateBtn) {
                                generateBtn.style.display = 'none';
                            }
                        } else {
                            showStatus(`‚ö†Ô∏è Failed to save commanders to server: ${error.message}`);
                        }
                    });
                
            } catch (error) {
                console.error(`‚ùå [GEN-P${playerNumber}] Error generating commanders:`, error);
                showStatus(`Error generating commanders: ${error.message}`);
                commandersGrid.innerHTML = '<em style="color: #f44336;">Error loading commanders. Please try again.</em>';
            }
        };

        window.selectCommander = function(playerNumber, commanderIndex, checkbox) {
            // Find the current player's number from their ID
            const currentPlayer = currentSession.players.find(p => p.id === currentPlayerId);
            const currentPlayerNumber = currentPlayer ? currentPlayer.number : null;
            
            // Validate we have the session state
            if (!currentSession) {
                console.error('‚ùå [SELECT] No session found!');
                checkbox.checked = !checkbox.checked;
                return;
            }
            
            // Only allow current player to select commanders
            if (playerNumber !== currentPlayerNumber) {
                console.log(`üö´ [SELECT-P${playerNumber}] Blocked - Not current player number (${currentPlayerNumber}, ID: ${currentPlayerId})`);
                checkbox.checked = !checkbox.checked; // Revert the change
                return;
            }
            
            // Prevent selection if player is already locked
            if (currentPlayer && currentPlayer.commanderLocked) {
                console.log(`üîí [SELECT-P${playerNumber}] Blocked - Player is already locked`);
                checkbox.checked = !checkbox.checked; // Revert the change
                return;
            }
            
            console.log(`‚úÖ [SELECT-P${playerNumber}] Commander ${commanderIndex} ${checkbox.checked ? 'selected' : 'deselected'}`);
            
            // Uncheck all other checkboxes for this player
            const checkboxes = document.querySelectorAll(`input[name="commander-select-${playerNumber}"]`);
            checkboxes.forEach((cb, idx) => {
                if (idx !== commanderIndex) {
                    cb.checked = false;
                    const item = document.getElementById(`commander-${playerNumber}-${idx}`);
                    if (item) item.classList.remove('selected');
                }
            });
            
            // Update selected state
            const item = document.getElementById(`commander-${playerNumber}-${commanderIndex}`);
            if (checkbox.checked) {
                console.log(`üéØ [SELECT-P${playerNumber}] Marking commander ${commanderIndex} as selected`);
                item.classList.add('selected');
                gameModeController.selectCommander(playerNumber, commanderIndex);
                console.log(`üîç [SELECT-P${playerNumber}] Stored value: ${gameModeController.playerSelectedCommander[playerNumber]}, Type: ${typeof gameModeController.playerSelectedCommander[playerNumber]}`);
                
                // Enable lock button
                const lockBtn = document.getElementById(`lock-btn-${playerNumber}`);
                if (lockBtn) {
                    lockBtn.disabled = false;
                    console.log(`üîì [SELECT-P${playerNumber}] Lock button enabled`);
                }
            } else {
                item.classList.remove('selected');
                
                // Disable lock button
                const lockBtn = document.getElementById(`lock-btn-${playerNumber}`);
                if (lockBtn) {
                    lockBtn.disabled = true;
                    console.log(`üîí [SELECT-P${playerNumber}] Lock button disabled`);
                }
            }
        };

        window.openCommanderLink = function(url) {
            if (url && url.trim() !== '') {
                console.log('üîó [LINK] Opening commander EDHRec page:', url);
                window.open(url, '_blank');
            } else {
                console.log('‚ö†Ô∏è [LINK] No URL available for this commander');
            }
        };

        window.lockCommander = async function(playerNumber) {
            console.log(`üîí [LOCK-P${playerNumber}] Lock commander clicked`);
            
            // Validate session state before proceeding
            if (!validateSessionState()) {
                showStatus('Error: Session state invalid. Please refresh the page.');
                return;
            }
            
            // Check if player is already locked
            const player = currentSession.players.find(p => p.number === playerNumber);
            if (player && player.commanderLocked) {
                console.log(`üö´ [LOCK-P${playerNumber}] Blocked - Player is already locked`);
                showStatus('Commander already locked!');
                return;
            }
            
            showStatus(`Locking commander for Player ${playerNumber}...`);
            
            try {
                console.log(`üì° [LOCK-P${playerNumber}] Calling lockCommanderForPlayer...`);
                const session = await gameModeController.lockCommanderForPlayer(playerNumber);
                console.log(`‚úÖ [LOCK-P${playerNumber}] Commander locked, session updated:`, session);
                
                currentSession = session;
                gameModeController.currentSession = session;
                
                // Update UI to show locked state
                const playerSection = document.getElementById(`player-${playerNumber}`);
                playerSection.classList.add('locked');
                
                const playerStatus = playerSection.querySelector('.player-status');
                if (playerStatus) playerStatus.textContent = 'üîí Locked';
                
                // Update the commanders grid to show large locked commander
                const commandersGrid = document.getElementById(`commanders-${playerNumber}`);
                if (commandersGrid) {
                    const lockedPlayer = currentSession.players.find(p => p.number === playerNumber);
                    if (lockedPlayer) {
                        console.log(`üé® [LOCK-P${playerNumber}] Updating grid to show locked commander`);
                        commandersGrid.innerHTML = renderCommanders(lockedPlayer);
                    }
                }
                
                // Disable and hide lock button
                const lockBtn = document.getElementById(`lock-btn-${playerNumber}`);
                if (lockBtn) {
                    lockBtn.disabled = true;
                    lockBtn.textContent = 'üîí Commander Locked';
                    lockBtn.style.display = 'none'; // Hide the button completely
                }
                
                console.log(`‚úÖ [LOCK-P${playerNumber}] UI updated`);
                showStatus('Commander locked! Waiting for other players...');
                
                // Check if all locked
                const allLocked = gameModeController.allPlayersLocked();
                console.log(`üîç [LOCK-P${playerNumber}] All players locked:`, allLocked);
                if (allLocked && !packCodesAlreadyShown) {
                    console.log(`üéâ [LOCK-P${playerNumber}] All players locked! Showing pack codes...`);
                    packCodesAlreadyShown = true;
                    showPackCodes();
                }
            } catch (error) {
                console.error(`‚ùå [LOCK-P${playerNumber}] Error locking commander:`, error);
                showStatus(`Error locking commander: ${error.message}`);
            }
        };

        function attachColorFilterListeners() {
            document.querySelectorAll('.color-filter-checkboxes').forEach(container => {
                const mode = container.dataset.mode;
                const maxCount = parseInt(container.dataset.count) || 0;
                const playerNumber = parseInt(container.dataset.player);
                
                // Only attach listeners if this is the current player's filter
                const isCurrentPlayer = currentSession?.players?.find(p => p.number === playerNumber)?.id === currentPlayerId;
                if (!isCurrentPlayer) return;
                
                const checkboxes = container.querySelectorAll('.color-input');
                const warningElement = container.closest('.player-settings')?.querySelector('.color-filter-warning');
                
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const selectedCount = container.querySelectorAll('.color-input:checked').length;
                        
                        if (mode === 'exclude' || mode === 'include') {
                            // Limited selection mode
                            if (selectedCount > maxCount) {
                                // Prevent selecting more than allowed
                                e.target.checked = false;
                                
                                // Show warning message
                                if (warningElement) {
                                    warningElement.style.opacity = '1';
                                    setTimeout(() => {
                                        warningElement.style.opacity = '0';
                                    }, 2000);
                                }
                            }
                        }
                        // For 'exact' mode, allow any number of selections
                    });
                });
            });
        }

        function startPolling() {
            console.log('üîÑ [POLLING] Starting session polling (500ms interval)');
            
            // Clear any existing interval first
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            
            let pollCount = 0;
            
            pollingInterval = setInterval(async () => {
                if (!currentSession) {
                    return; // Silent skip when no session
                }
                
                pollCount++;
                
                // Periodic health check (every 20 polls = ~10 seconds)
                if (pollCount % 20 === 0) {
                    if (!validateSessionState()) {
                        console.warn('‚ö†Ô∏è [HEALTH-CHECK] Session state out of sync, attempting recovery...');
                        // State will be auto-fixed by validateSessionState
                    }
                }
                
                try {
                    const session = await sessionManager.getSession(currentSession.sessionCode);
                    
                    // Check if current player was kicked from session
                    const currentPlayerInSession = session.players.find(p => p.id === currentPlayerId);
                    if (!currentPlayerInSession || currentPlayerInSession.isKicked) {
                        console.log('üë¢ [POLLING] Current player kicked from session');
                        
                        // Stop polling immediately
                        if (pollingInterval) {
                            clearInterval(pollingInterval);
                            pollingInterval = null;
                            console.log('üë¢ [POLLING] Stopped polling after being kicked');
                        }
                        
                        // DON'T clear localStorage - keep player ID so they can rejoin with their slot
                        // sessionManager.clearPlayerIdFromStorage(currentSession.sessionCode);
                        
                        // Clear current session
                        currentSession = null;
                        currentPlayerId = null;
                        
                        // Navigate back to home screen immediately
                        hideAllPages();
                        window.history.pushState({}, document.title, window.location.pathname);
                        location.reload();
                        
                        return; // Stop processing this update
                    }
                    
                    const previousState = currentSession.state;
                    currentSession = session;
                    
                    // CRITICAL: Always keep gameModeController in sync
                    gameModeController.currentSession = session;
                    gameModeController.currentPlayerId = currentPlayerId;
                    
                    // Sync commanders data from all players (in case others generated while we were away)
                    session.players.forEach(player => {
                        if (player.commanders && player.commanders.length > 0 && !player.isKicked) {
                            gameModeController.playerCommanderData[player.number] = player.commanders.map(normalizeCommanderData);
                            
                            // Restore selected commander index
                            if (player.selectedCommanderIndex !== undefined && player.selectedCommanderIndex !== null) {
                                gameModeController.playerSelectedCommander[player.number] = player.selectedCommanderIndex;
                            }
                        }
                    });
                    
                    // Update lobby if in lobby state
                    if (session.state === 'waiting' && !lobbySection.classList.contains('hidden')) {
                        updateLobbyPlayers();
                    }
                    
                    // Check if we should show perk reveal
                    // Show if: state is 'selecting' AND player hasn't seen perks yet
                    const currentPlayer = session.players.find(p => p.id === currentPlayerId);
                    const shouldShowReveal = session.state === 'selecting' && 
                                           currentPlayer && 
                                           !currentPlayer.hasSeenPerks &&
                                           !document.getElementById('perk-reveal-page').classList.contains('active');
                    
                    if (shouldShowReveal) {
                        console.log('üé≤ [POLLING] Perks ready and not seen - showing reveal page');
                        
                        // If they're on name entry screen, skip to reveal
                        if (!enterNameSection.classList.contains('hidden')) {
                            console.log('üìù [POLLING] Player on name entry, moving to reveal');
                        }
                        
                        showPerkReveal(session);
                        return; // Don't proceed to enterGameMode yet
                    }
                    
                    // Update UI based on state
                    if (session.state === 'selecting' && playerGridSection.classList.contains('hidden') && document.getElementById('perk-reveal-page').classList.contains('active')) {
                        // Already on perk reveal page, don't enter game mode yet
                        console.log('üé¥ [POLLING] Perk reveal in progress, waiting...');
                    } else if (session.state === 'selecting' && playerGridSection.classList.contains('hidden') && !document.getElementById('perk-reveal-page').classList.contains('active')) {
                        console.log('üéÆ [POLLING] State changed to selecting - entering game mode');
                        packCodesAlreadyShown = false; // Reset when entering game mode
                        enterGameMode();
                    }
                    
                    // Update player grid if visible (regardless of state - other players might lock/generate)
                    if (!playerGridSection.classList.contains('hidden')) {
                        updatePlayerStatuses();
                    }
                    
                    // Check if all locked - only show pack codes ONCE
                    const allLocked = gameModeController.allPlayersLocked();
                    console.log(`üîç [POLLING] Lock check - allLocked: ${allLocked}, state: ${session.state}, alreadyShown: ${packCodesAlreadyShown}, gridHidden: ${playerGridSection.classList.contains('hidden')}`);
                    
                    if (allLocked && session.state === 'complete' && !packCodesAlreadyShown) {
                        console.log('üéâ [POLLING] All players locked - showing pack codes');
                        packCodesAlreadyShown = true;
                        showPackCodes();
                    }
                } catch (error) {
                    console.error('‚ùå [POLLING] Error:', error);
                }
            }, 500);
        }

        function showPackCodes() {
            // Prevent re-rendering if already shown
            if (packCodesAlreadyShown && !packCodesSection.classList.contains('hidden')) {
                console.log('‚è≠Ô∏è [PACK-CODES] Already shown, skipping re-render');
                return;
            }
            
            console.log('üì¶ [PACK-CODES] Showing pack codes section');
            packCodesAlreadyShown = true; // Mark as shown
            
            playerGridSection.classList.add('hidden');
            packCodesSection.classList.remove('hidden');
            document.getElementById('tts-instructions').classList.remove('hidden');
            console.log('üîÑ [PACK-CODES] View switched - grid hidden, codes shown');
            
            const packCodeList = document.getElementById('pack-code-list');
            packCodeList.innerHTML = '';
            
            console.log('üé® [PACK-CODES] Rendering pack codes for players:', currentSession.players);
            currentSession.players.forEach((player, index) => {
                console.log(`üë§ [PACK-CODES] Player ${player.number}:`, player);
                
                // Get commander data
                const commanderData = player.commanderData || {};
                const commanderName = commanderData.name || 'Unknown Commander';
                const commanderImage = commanderData.image_url || 'images/card-back.png';
                const commanderUrl = player.commanderUrl || '#';
                
                // Get powerup data (now an array)
                const powerups = player.perks || (player.perk ? [player.perk] : []);
                
                // Enrich powerups with full perk data (including emoji)
                const enrichedPowerups = powerups.map(perk => {
                    const fullPerkData = perksData.find(p => p.id === perk.id);
                    if (fullPerkData) {
                        return { ...perk, ...fullPerkData };
                    }
                    return perk;
                });
                
                // Sort powerups by rarity (common -> uncommon -> rare -> mythic)
                const raritySortOrder = { common: 1, uncommon: 2, rare: 3, mythic: 4 };
                const sortedPowerups = [...enrichedPowerups].sort((a, b) => {
                    const rarityA = raritySortOrder[a?.rarity || 'common'] || 1;
                    const rarityB = raritySortOrder[b?.rarity || 'common'] || 1;
                    return rarityA - rarityB;
                });
                
                const powerupsListHTML = sortedPowerups.length > 0 ? 
                    sortedPowerups.map(p => {
                        console.log('üîç [DEBUG PACK] Perk data:', p);
                        const phaseLabel = p.perkPhase === 'commander_selection' ? 'Commander Selection' : 'Drafting';
                        const tooltipText = `${phaseLabel} Perk: ${p.description || ''}`;
                        console.log('üîç [DEBUG PACK] Tooltip text:', tooltipText);
                        return `
                        <div class="pack-perk-item ${p.rarity || 'common'}" title="${tooltipText}" style="cursor: help;">
                            ${p.emoji ? p.emoji + ' ' : ''}${p.name || 'Unknown'}
                        </div>
                    `}).join('') :
                    '<div class="pack-perk-item common">No Powerups</div>';
                
                const div = document.createElement('div');
                div.className = 'pack-code-item';
                div.innerHTML = `
                    <div class="pack-player-header">
                        <h3 class="pack-player-name">${player.name}</h3>
                    </div>
                    
                    <div class="pack-commander-display">
                        <div class="pack-commander-img-container">
                            <img src="${commanderImage}" 
                                 alt="${commanderName}" 
                                 class="pack-commander-img"
                                 onclick="openCommanderLink('${commanderUrl}')"
                                 title="Click to view on EDHRec">
                        </div>
                        <div class="pack-commander-info">
                            <h4 class="pack-commander-name">${commanderName}</h4>
                            <div class="pack-perks-list">
                                ${powerupsListHTML}
                            </div>
                        </div>
                    </div>
                    
                    <div class="pack-code-display">
                        <div class="pack-code-label">TTS Pack Code:</div>
                        <div class="pack-code">${player.packCode || 'Generating...'}</div>
                        <button class="btn btn-small" onclick="copyPackCode('${player.packCode}')" style="margin-top: 0.5rem; width: 100%;" title="Click to copy the TTS chat command">üìã Copy TTS Command</button>
                    </div>
                `;
                packCodeList.appendChild(div);
                console.log(`‚úÖ [PACK-CODES] Player ${player.number} code rendered`);
            });
            
            console.log('‚úÖ [PACK-CODES] All pack codes rendered');
        }

        window.copyPackCode = function(code) {
            console.log('üìã [COPY] Copying pack code:', code);
            const ttsCommand = `edhrandomizer ${code}`;
            navigator.clipboard.writeText(ttsCommand);
            showStatus(`‚úÖ Copied to clipboard! Paste "${ttsCommand}" in TTS chat.`);
            console.log('‚úÖ [COPY] TTS command copied to clipboard:', ttsCommand);
        };

        function showStatus(message) {
            console.log(`üì¢ [STATUS] ${message}`);
            statusMessage.textContent = message;
            setTimeout(() => {
                if (statusMessage.textContent === message) {
                    statusMessage.textContent = '';
                }
            }, 3000);
        }

        // Start initialization
        init();
    </script>
</body>
</html>

